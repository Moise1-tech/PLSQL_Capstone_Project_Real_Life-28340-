-- Run as moise_admin
CREATE TABLE secure_users (
  user_id      NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  username     VARCHAR2(50) UNIQUE NOT NULL,
  password_hash VARCHAR2(200) NOT NULL,
  role         VARCHAR2(20) DEFAULT 'USER' NOT NULL,
  is_locked    CHAR(1) DEFAULT 'N' CHECK (is_locked IN ('Y','N')),
  failed_attempts NUMBER DEFAULT 0,
  locked_at    TIMESTAMP NULL,
  created_at   TIMESTAMP DEFAULT SYSTIMESTAMP,
  last_login   TIMESTAMP NULL
);

CREATE TABLE login_log (
  log_id       NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  user_id      NUMBER NULL,
  username     VARCHAR2(50) NOT NULL,
  status       VARCHAR2(10) CHECK (status IN ('SUCCESS','FAILED')),
  src_ip       VARCHAR2(45),
  attempt_time TIMESTAMP DEFAULT SYSTIMESTAMP,
  details      VARCHAR2(4000),
  CONSTRAINT fk_login_user FOREIGN KEY (user_id) REFERENCES secure_users(user_id)
);

CREATE TABLE account_locks (
  lock_id      NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  user_id      NUMBER NOT NULL,
  lock_reason  VARCHAR2(200),
  lock_time    TIMESTAMP DEFAULT SYSTIMESTAMP,
  unlock_time  TIMESTAMP NULL,
  unlocked_by  VARCHAR2(50),
  CONSTRAINT fk_lock_user FOREIGN KEY (user_id) REFERENCES secure_users(user_id)
);

CREATE TABLE holidays (
  holiday_date DATE PRIMARY KEY,
  description  VARCHAR2(200)
);

CREATE TABLE audit_log (
  audit_id     NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  table_name   VARCHAR2(100),
  action       VARCHAR2(20),
  performed_by VARCHAR2(50),
  performed_at TIMESTAMP DEFAULT SYSTIMESTAMP,
  success_flag CHAR(1) CHECK (success_flag IN ('Y','N')),
  details      VARCHAR2(4000)
);
 
 BEGIN
  -- create admin user
  INSERT INTO secure_users (username, password_hash, role)
  VALUES ('admin', STANDARD_HASH('Admin@123','SHA256'), 'ADMIN');

  -- create 199 regular users
  FOR i IN 1..199 LOOP
    INSERT INTO secure_users (username, password_hash)
    VALUES (
      'user_' || lpad(i,3,'0'),
      STANDARD_HASH('P@ss' || i, 'SHA256')
    );
  END LOOP;
  COMMIT;
END;
/

-- Create randomized login attempts: mixture of successes and failures
DECLARE
  v_count NUMBER := 1000;
  v_user_count NUMBER;
  v_user_id NUMBER;
  v_username VARCHAR2(50);
  v_status VARCHAR2(10);
  v_ip VARCHAR2(45);
BEGIN
  SELECT COUNT(*) INTO v_user_count FROM secure_users;

  FOR i IN 1..v_count LOOP
    -- pick a random user
    v_user_id := TRUNC(DBMS_RANDOM.VALUE(1, v_user_count+1));
    SELECT username INTO v_username FROM secure_users WHERE user_id = v_user_id;

    -- randomly decide status, make ~15% failures
    IF DBMS_RANDOM.VALUE(0,1) < 0.15 THEN
      v_status := 'FAILED';
    ELSE
      v_status := 'SUCCESS';
    END IF;

    v_ip := TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(1,255))) || '.' ||
            TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(1,255))) || '.' ||
            TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(1,255))) || '.' ||
            TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(1,255)));

    INSERT INTO login_log (user_id, username, status, src_ip, details)
    VALUES (v_user_id, v_username, v_status, v_ip, 'Auto-generated test data');
  END LOOP;
  COMMIT;
END;
/


CREATE OR REPLACE PACKAGE pkg_auth IS
  -- config
  c_lock_threshold CONSTANT NUMBER := 5; -- failed attempts
  c_lock_duration_minutes CONSTANT NUMBER := 30;

  FUNCTION hash_password(p_plain IN VARCHAR2) RETURN VARCHAR2;
  PROCEDURE create_user(p_username IN VARCHAR2, p_password IN VARCHAR2, p_role IN VARCHAR2 := 'USER');
  PROCEDURE authenticate(p_username IN VARCHAR2, p_password IN VARCHAR2, p_src_ip IN VARCHAR2, p_result OUT VARCHAR2);
  PROCEDURE unlock_user(p_username IN VARCHAR2, p_admin IN VARCHAR2);
  FUNCTION is_holiday(p_date IN DATE) RETURN BOOLEAN;
END pkg_auth;
/
CREATE OR REPLACE PACKAGE BODY pkg_auth IS

  FUNCTION hash_password(p_plain IN VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    RETURN STANDARD_HASH(p_plain, 'SHA256');
  END;

  PROCEDURE create_user(p_username IN VARCHAR2, p_password IN VARCHAR2, p_role IN VARCHAR2 := 'USER') IS
  BEGIN
    INSERT INTO secure_users(username, password_hash, role)
    VALUES (p_username, hash_password(p_password), p_role);
    INSERT INTO audit_log(table_name, action, performed_by, success_flag, details)
    VALUES ('SECURE_USERS', 'INSERT', USER, 'Y', 'Created user '||p_username);
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      INSERT INTO audit_log(table_name, action, performed_by, success_flag, details)
      VALUES ('SECURE_USERS', 'INSERT', USER, 'N', SQLERRM||' for '||p_username);
      RAISE;
  END;

  PROCEDURE authenticate(p_username IN VARCHAR2, p_password IN VARCHAR2, p_src_ip IN VARCHAR2, p_result OUT VARCHAR2) IS
    v_hashed VARCHAR2(200);
    v_user_id NUMBER;
    v_is_locked CHAR(1);
    v_failed NUMBER;
  BEGIN
    SELECT user_id, password_hash, is_locked, failed_attempts
      INTO v_user_id, v_hashed, v_is_locked, v_failed
      FROM secure_users
     WHERE username = p_username;

    IF v_is_locked = 'Y' THEN
      p_result := 'LOCKED';
      INSERT INTO login_log(user_id, username, status, src_ip, details)
      VALUES (v_user_id, p_username, 'FAILED', p_src_ip, 'Account locked');
      COMMIT;
      RETURN;
    END IF;

    IF v_hashed = hash_password(p_password) THEN
      -- success
      UPDATE secure_users SET failed_attempts = 0, last_login = SYSTIMESTAMP WHERE user_id = v_user_id;
      INSERT INTO login_log(user_id, username, status, src_ip, details)
        VALUES (v_user_id, p_username, 'SUCCESS', p_src_ip, 'Authenticated');
      p_result := 'SUCCESS';
      COMMIT;
    ELSE
      -- failed attempt
      v_failed := v_failed + 1;
      UPDATE secure_users SET failed_attempts = v_failed WHERE user_id = v_user_id;
      INSERT INTO login_log(user_id, username, status, src_ip, details)
        VALUES (v_user_id, p_username, 'FAILED', p_src_ip, 'Bad password');
      -- if threshold reached, lock account
      IF v_failed >= c_lock_threshold THEN
        UPDATE secure_users SET is_locked = 'Y', locked_at = SYSTIMESTAMP WHERE user_id = v_user_id;
        INSERT INTO account_locks(user_id, lock_reason) VALUES (v_user_id, 'Lockout after '||v_failed||' failed attempts');
      END IF;
      p_result := 'FAILED';
      COMMIT;
    END IF;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      -- record failed unknown username
      INSERT INTO login_log(user_id, username, status, src_ip, details)
        VALUES (NULL, p_username, 'FAILED', p_src_ip, 'Unknown username');
      p_result := 'UNKNOWN';
      COMMIT;
  END;

  PROCEDURE unlock_user(p_username IN VARCHAR2, p_admin IN VARCHAR2) IS
    v_user_id NUMBER;
  BEGIN
    SELECT user_id INTO v_user_id FROM secure_users WHERE username = p_username;
    UPDATE secure_users SET is_locked = 'N', failed_attempts = 0, locked_at = NULL WHERE user_id = v_user_id;
    UPDATE account_locks SET unlock_time = SYSTIMESTAMP, unlocked_by = p_admin
      WHERE user_id = v_user_id AND unlock_time IS NULL;
    INSERT INTO audit_log(table_name, action, performed_by, success_flag, details)
      VALUES ('SECURE_USERS', 'UNLOCK', p_admin, 'Y', 'Unlocked '||p_username);
    COMMIT;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    INSERT INTO audit_log(table_name, action, performed_by, success_flag, details)
      VALUES ('SECURE_USERS', 'UNLOCK', p_admin, 'N', 'User not found '||p_username);
    COMMIT;
  END;

  FUNCTION is_holiday(p_date IN DATE) RETURN BOOLEAN IS
    v_cnt NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_cnt FROM holidays WHERE TRUNC(holiday_date) = TRUNC(p_date);
    RETURN v_cnt > 0;
  END;

END pkg_auth;
/

DECLARE
  CURSOR c_suspicious IS
    SELECT username, failed_attempts, is_locked, last_login
      FROM secure_users
     WHERE failed_attempts >= 3
     ORDER BY failed_attempts DESC;
BEGIN
  FOR r IN c_suspicious LOOP
    DBMS_OUTPUT.PUT_LINE(r.username || ' fails=' || r.failed_attempts || ' locked=' || r.is_locked);
  END LOOP;
END;
/

CREATE OR REPLACE TRIGGER trg_audit_secure_users
AFTER INSERT OR UPDATE OR DELETE ON secure_users
FOR EACH ROW
DECLARE
  v_action VARCHAR2(20);
BEGIN
  IF INSERTING THEN v_action := 'INSERT';
  ELSIF UPDATING THEN v_action := 'UPDATE';
  ELSIF DELETING THEN v_action := 'DELETE';
  END IF;

  INSERT INTO audit_log(table_name, action, performed_by, success_flag, details)
  VALUES ('SECURE_USERS', v_action, USER, 'Y', 'Row user=' || NVL(:NEW.username, :OLD.username));

EXCEPTION
  WHEN OTHERS THEN
    NULL; -- avoid breaking DML path; log failures elsewhere if needed
END;
/


CREATE OR REPLACE TRIGGER trg_restrict_user_changes
BEFORE INSERT OR UPDATE OR DELETE ON secure_users
FOR EACH ROW
DECLARE
  v_weekday NUMBER;
  v_is_hol  BOOLEAN;
BEGIN
  -- allow DBA or admins (simple check; in real life check SESSION_USER properly)
  IF USER = 'MOISE_ADMIN' THEN
    RETURN;
  END IF;

  -- find current weekday (1=Sunday, 2=Monday ... 7=Saturday)
  SELECT TO_CHAR(SYSDATE, 'D') INTO v_weekday FROM DUAL;

  v_is_hol := pkg_auth.is_holiday(TRUNC(SYSDATE));

  -- if weekday (Mon-Fri -> depending on NLS_TERRITORY, safer to use day name):
  IF NOT (TO_CHAR(SYSDATE,'DY','NLS_DATE_LANGUAGE=ENGLISH') IN ('SAT','SUN')) OR v_is_hol THEN
    RAISE_APPLICATION_ERROR(-20001, 'DML on SECURE_USERS is restricted on weekdays and public holidays.');
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    RAISE;
END;
/

-- Daily success/failure
SELECT TRUNC(attempt_time) day,
       SUM(CASE WHEN status='SUCCESS' THEN 1 ELSE 0 END) success_count,
       SUM(CASE WHEN status='FAILED' THEN 1 ELSE 0 END) fail_count
FROM login_log
GROUP BY TRUNC(attempt_time)
ORDER BY day DESC;

-- Top suspicious users
SELECT username, COUNT(*) failed_count
FROM login_log
WHERE status = 'FAILED'
GROUP BY username
ORDER BY failed_count DESC
FETCH FIRST 10 ROWS ONLY;

-- Current locked accounts
SELECT username, failed_attempts, locked_at FROM secure_users WHERE is_locked='Y';



------- innovation and addition to the project-----------
CONNECT employee_user/Password123;

INSERT INTO secure_users(username, password_hash, role)
VALUES ('test_user', STANDARD_HASH('Test123', 'SHA256'), 'USER');


